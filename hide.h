#ifndef HIDE_H
#define HIDE_H

#include <random>
#include <math.h>

namespace hide {
	//Returns a vector containing a pseudo-random permutation of [0,1,...,length-1]
	//Preconditions: length > 0
	std::vector<size_t>  random_permutation(size_t length, const std::string& seed) {
		//Create a vector containing [0,1,...length-1]
		std::vector<size_t> sequence(length);
		for (size_t i = 0; i < length; i++) {
			sequence[i] = i;
		}
		
		//Initialize the pseudo-random number generator
		std::seed_seq seedSequence(seed.begin(), seed.end());	
		std::mt19937 mt (seedSequence);

		//Shuffle the vector (Fisher-Yates shuffle)
		for (size_t i = 0; i < length - 1; i++) {
			//Generate a random number between i and length-1, inclusive
			std::uniform_int_distribution<size_t> uniform(i, length-1);
			size_t j = uniform(mt);

			//Swap sequence[i] and sequence[j]
			size_t temp = sequence[i];
			sequence[i] = sequence[j];
			sequence[j] = temp;
		}
		return sequence;
	}
	
	//Returns the least significant bit of the byte pixel
	bool extractSymbol(const uint8_t& pixel) {
		return ((pixel & 1) != 0);
	}
	
	//Embeds the bit symbol in the byte pixel such that the least significant bit of pixel is equal to symbol.
	//Implements the least significant bit matching (LSBM) method of steganography.
	void embedSymbol(uint8_t& pixel, bool symbol, bool random) {
		if (symbol == extractSymbol(pixel)) {
			return;
		}
		else if (pixel == 0) {
			pixel++;
		}
		else if (pixel == UINT8_MAX) {
			pixel--;
		}
		else {
			pixel = random ? (pixel + 1) : (pixel - 1);
		}
	}

	//Returns the largest x s.t. x + pow(2, x) - 1 does not exceed imageSize.
	//Precondition: imageSize > 1
	size_t getHeaderSize(size_t imageSize) {
		size_t candidateSize = 1;
		while (candidateSize + pow(2, candidateSize) - 1 <= imageSize) {
			candidateSize++;
		}
		return candidateSize - 1;
	}

	//Returns the binary representation of messageLength as a vector of bits, padded on the left to a size of exactly headerSize
	//Preconditions: the binary representation of messageLength has a width of at most headerSize
	std::vector<bool> getHeader(size_t messageLength, size_t headerSize) {	
		std::vector<bool> header;
		while (messageLength > 0) {
			header.push_back((messageLength & 1) != 0);
			messageLength >>= 1;
		}

		//If the length of the message cannot be contained in the header, abort
		if (header.size() > headerSize) return std::vector<bool>{};
		//TODO: Throw an exception

		while (header.size() < headerSize) {
			header.push_back(false);
		}
		std::reverse(header.begin(), header.end());
		return header;
	}

	//Given a message header generated by getHeader(), returns the corresponding message size
	size_t getLengthFromHeader(std::vector<bool> header) {
		size_t length = 0;
		for (bool bit : header) {
			length *= 2;
			if (bit) length++;
		}
		return length;
	}

	//Returns a binary representation of an ASCII string.
	std::vector<bool> toBits(const std::string& str) {
		std::vector<bool> bits;
		for (char c : str) {
			for (unsigned int mask = 1; mask < SCHAR_MAX; mask <<= 1) {
				bits.push_back((c & mask) != 0);	
			}
		}
		return bits;
	}	

	//Given a binary representation of an ASCII string, returns the corresponding string.
	std::string toString(const std::vector<bool>& bits) {
		size_t bitsASCII = 7;
		if (bits.size() % bitsASCII != 0) return NULL; //Throw an error
		//TODO: Throw an exception

		std::string str;
		for (size_t characterNumber = 0; characterNumber < bits.size() / bitsASCII; characterNumber++) {
			char c;
			unsigned int mask;
			size_t bitNumber;
			for (c = 0, mask = 1, bitNumber = 0; mask < SCHAR_MAX; mask <<= 1, bitNumber++) {
				if (bits[characterNumber * bitsASCII + bitNumber]) c |= mask;
			}
			str.push_back(c);
		}
		return str;
	}	

	//Uses LSB matching steganography to embed the string message within the vector image, with the order of embedding determined by the secret key.
	void embed(std::vector<uint8_t>& image, const std::string& message, const std::string& key) {
		//Convert message to bits
		std::vector<bool> messageBits = toBits(message);

		//Generate permuation
		std::vector<size_t> permutation = random_permutation(image.size(), key);
		size_t positionInPermutation = 0;

		//Create true random number generator
		std::random_device rng;
		std::uniform_int_distribution<int> coinFlip(0,1);

		//Prepend header to message
		size_t headerSize = getHeaderSize(image.size());
		std::vector<bool> headerPlusMessage = getHeader(messageBits.size(), headerSize);
		headerPlusMessage.insert(headerPlusMessage.end(), messageBits.begin(), messageBits.end());
		
		//Embed header + message in image
		for (bool headerOrMessageBit : headerPlusMessage) {
			embedSymbol(image[permutation[positionInPermutation]], headerOrMessageBit, coinFlip(rng));
			positionInPermutation++;
		}
	}
	
	//Returns the message embedded in the vector image given by the secret key.
	//Will always return a message for all inputs, even for images which have not been passed to embed() or images passed to embed() with a different secret key.
	std::string extract(const std::vector<uint8_t>& image, const std::string& key) {
		//Initialize storage to hold header + message bits
		std::vector<bool> headerPlusMessage;

		//Generate permutation from key
		std::vector<size_t> permutation = random_permutation(image.size(), key);
		size_t positionInPermutation = 0;

		//Read the header and message from the image
		size_t headerSize = getHeaderSize(image.size());
		size_t messageLength = 0;
		while (positionInPermutation < headerSize + messageLength) {
			headerPlusMessage.push_back(extractSymbol(image[permutation[positionInPermutation]]));
			positionInPermutation++;
			if (positionInPermutation == headerSize) messageLength = getLengthFromHeader(headerPlusMessage);
		}
		
		//Convert bits to char
		std::vector<bool> message;
		message.assign(headerPlusMessage.begin() + headerSize, headerPlusMessage.end());
		return toString(message);
	}
}

#endif
